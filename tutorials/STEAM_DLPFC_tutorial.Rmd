---
title: "Tutorial of applying STEAM to evaluate clustering performance using the DLPFC spatial transcriptomic data"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: true
    number_sections: true
  pdf_document: default
editor_options:
  chunk_output_type: console
  markdown:
    wrap: sentence
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 8, fig.height = 5,
  warning = FALSE, message = FALSE
)
```

# Overview

This vignette outlines the steps of applying STEAM on the 10X Visium DLPFC (Dorsolateral Prefrontal Cortex) data.
Four different classification models are implemented in STEAM to evaluate clustering results, including Random Forest, Support Vector Machines, XGBoost, and Multinomial Logistic Regression.

Here, cell-type classification is performed by incorporating spatial neighborhood analysis and Random Forest model with cross validation.

Before using STEAM, we recommend preprocessing your spatial transcriptomics data using the **Seurat** framework, as it provides a robust set of tools for spatial data normalization, scaling, and visualization.
The Satija Lab offers detailed vignettes to guide you through spatial data preprocessing:

-   \- [Seurat Spatial Vignette (Part 1)](https://satijalab.org/seurat/articles/spatial_vignette.html)

-   \- [Seurat Spatial Vignette (Part 2 - Seurat v5)](https://satijalab.org/seurat/articles/spatial_v5.html)

-   [Visium HD Analysis Vignette](https://satijalab.org/seurat/articles/spatial_hd.html)

To run STEAM, you need the following components:

-   A normalized gene expression matrix

-   An X,Y spatial coordinates matrix

-   A vector of ground truth or predicted labels

------------------------------------------------------------------------

# Load libraries

```{r}
library(STEAM)
library(Seurat)
```

# 1. Data Loading

# Load data

DLPFC.RDS is sample 151669 from the DLPFC dataset from Visium by 10X Genomics.
This data is already preprocessed and includes a `SCTransform` scaled data matrix by `Seurat`, spatial coordinates, and pre-identified cluster labels

```{r}
data(DLPFC)
```

## 1.1 Load from a Seurat object

You can input this data into STEAM in two ways:

```{r Seurat example, include= FALSE}
# STEAM.obj <- LoadSTEAM(
#   Seurat.obj   = DLPFC,
#   label.column = "Labels",
#   assay        = "SCT"
# )
```

**Parameters**

-   `Seurat.obj` — a `Seurat` object with counts and metadata.
-   `label.column` — metadata column containing the **ground‑truth** labels (e.g., cortical layer, cell type).
-   `assay` — which assay to read (e.g., `"SCT"`, `"RNA"`).

**Outputs** - `STEAM.obj$count_exp`, `STEAM.obj$labels`, `STEAM.obj$spatial` (if present in the Seurat object), and optional embeddings (PCA/UMAP) if available.

## 1.2 Load from matrices / data.frames

```{r}
STEAM.obj <- LoadSTEAM(
  count_exp = DLPFC$matrix,     # genes x cells (or cells x genes; see package docs)
  spatial   = DLPFC$coordinates,   # data.frame with rownames=cell_id and X/Y columns
  labels    = DLPFC$labels,   # named vector: names = cell_id, values = label
  # pca       = pca,      # optional matrix/data.frame
  # umap      = umap,     # optional matrix/data.frame
  # clusters  = labels    # optional alternative cluster labels
)
```

**Parameters**

-   `count_exp` — expression matrix.

-   `spatial` — coordinates; must align rownames with cell IDs used elsewhere.

-   `labels` — named vector of reference labels (ground truth).

-   `pca`, `umap`, `clusters` — optional; used for diagnostics/plots.

**Common checks** - Row/column names must be consistent across objects.

-   No duplicated cell IDs.

-   `labels` must cover all cells you plan to evaluate.

------------------------------------------------------------------------

# 2. Train & Evaluate (Nested CV)

STEAM.obj \<- RunSTEAM(

STEAM.obj, mode = "nested",

n_outer_folds = 5, n_inner_folds = 3,

cv.cores = 10, \# parallel across outer folds

allowParallel = FALSE, \# inner caret loop sequential for determinism

n.size = 5,

model = "rf",

metric = "Kappa",

maxnweights = 15000

)

```{r}
STEAM.obj <- RunSTEAM(
  STEAM.obj, 
  mode = "nested",
  n_outer_folds = 5, n_inner_folds = 3,
  cv.cores = 1,             # parallel across outer folds
  allowParallel = FALSE,     
  n.size = 5,
  model = "rf",
  metric = "Kappa",
  maxnweights = 15000
)
```




**Key parameters**

-   `mode` — `"nested"` performs outer *and* inner cross‑validation (outer for unbiased evaluation; inner for tuning).

-   `n_outer_folds`, `n_inner_folds` — fold counts.

-   `cv.cores` — parallel workers for outer folds.

-   `allowParallel` — whether caret may parallelize inner CV (often `FALSE` to avoid nested parallelism contention).

-   `model`: The machine learning model to use for classification.

    -   `rf` = RandomForest

    -   `svm` = Support Vector Machines,

    -   `xgb` = XGBoost

    -   `multinom` = Multinomial Logistic Regression

-   `metric` — caret optimization metric (e.g., `"Accuracy"`, `"Kappa"`).

-   `maxnweights`, `n.size` — package‑specific compute/feature knobs.

**Outputs**

-   `STEAM.obj$nested$ncv` — nested CV object containing:

-   `outer_result[[i]]$preds` — **outer test predictions** per fold with `predy` (prediction), `testy` (truth), and per‑class probabilities.

-   `outer_result[[i]]$fit$pred` — **inner CV predictions** used for tuning.

**Diagnostics**

```{r}
ViewMetrics(STEAM.obj, view = "overall")
ViewMetrics(STEAM.obj, view = "fold")
ViewMetrics(STEAM.obj, fold = 1)

plot_misclassified_cells(STEAM.obj)
plot_misclassified_cells(STEAM.obj, fold = 1)

feature_importance(STEAM.obj)
feature_expression(STEAM.obj, "MBP", view = "pooled")
feature_expression(STEAM.obj, "MBP", view = "facet")
```

-   `ViewMetrics()` — tabular summaries overall / per fold.
-   `plot_misclassified_cells()` — visualize errors spatially or by fold.
-   `feature_importance()` — model‑specific importance (e.g., RF Gini/perm).
-   `feature_expression()` — expression of a gene/feature in different views.

# Custom Model Training Examples

```{r}

# Random Forest with custom tuning grid
rf_grid <- expand.grid(mtry = c(100, 200, 300))

STEAM.obj <- RunSTEAM(
  STEAM.obj,
  train.ratio = 0.8,
  n.size = 5,
  seed = 123,
  cv.folds = 5,
  cv.repeats = 1,
  trainval.ratio = 0.8,
  model = "rf",
  n.tree = 300,
  train.folder.name = "./model_rf",
  allowParallel = TRUE,
  tune.grid = rf_grid
)

# XGBoost with custom tuning grid
xgb_grid <- expand.grid(
  nrounds = c(100, 300),
  max_depth = c(3, 5),
  eta = c(0.05, 0.1),
  gamma = 0,
  colsample_bytree = 0.8,
  min_child_weight = 1,
  subsample = 0.8
)

STEAM.obj <- RunSTEAM(
  STEAM.obj,
  train.ratio = 0.8,
  n.size = 5,
  seed = 123,
  cv.folds = 5,
  cv.repeats = 1,
  trainval.ratio = 0.8,
  model = "xgb",
  train.folder.name = "./model_xgb",
  allowParallel = TRUE,
  tune.grid = xgb_grid
)

# SVM linear with custom tuning grid
svm_grid <- expand.grid(
  C = c(0.05, 0.1, 0.5, 1),
  sigma = c(0.001, 0.01, 0.05)
)

STEAM.obj <- RunSTEAM(
  STEAM.obj,
  train.ratio = 0.8,
  n.size = 5,
  seed = 123,
  cv.folds = 5,
  cv.repeats = 1,
  trainval.ratio = 0.8,
  model = "svm",
  kernel = "linear",
  train.folder.name = "./model_svm",
  allowParallel = TRUE,
  tune.grid = svm_grid
)


# Multinomial Logistic Regression with custom tuning grid
multinom_grid <- expand.grid(decay = c(1, 5, 10, 15))

STEAM.obj <- RunSTEAM(
  STEAM.obj,
  train.ratio = 0.8,
  n.size = 5,
  seed = 123,
  cv.folds = 5,
  cv.repeats = 1,
  trainval.ratio = 0.8,
  model = "multinom",
  train.folder.name = "./model_multinom",
  allowParallel = TRUE,
  maxnweights = 6000,
  tune.grid = multinom_grid
)


```

------------------------------------------------------------------------

# 2. STEAMCorrection Analysis

The STEAMCorrection system leverages spatial neighborhood information to identify and correct misclassified cells from your cross-validation results.
This approach is based on the biological principle that spatially adjacent cells often share similar tissue types or functional states.

## 2.1 Understanding the Algorithm

STEAMCorrection works by:

1.  **Identifying misclassified cells** from nested CV results

2.  **Finding spatial neighbors** using k-nearest neighbors

3.  **Applying hierarchical voting** where neighbors vote on the correct cell type

4.  **Making corrections iteratively** with adaptive consensus thresholds

5.  **Tracking progress** across multiple correction rounds

The algorithm uses a hierarchical voting system:

-   **1st choice corrections**: High consensus threshold (default 60%)

-   **2nd/3rd choice corrections**: Lower thresholds for difficult cases

-   **Stuck cell handling**: Even more lenient thresholds for cells that resist correction

## 2.2 Basic Usage

```{r}
# Run correction with default parameters
STEAM.obj <- STEAMCorrection(STEAM.obj)

```

This automatically processes all cross-validation folds with sensible defaults:

-   `k = 8` neighbors

-   `min_consensus = 0.6` (60% agreement for primary corrections)

-   `max_iterations = 10`

-   Hierarchical voting with up to 3 voting levels

## 2.3 Parameter Tuning

For optimal results, you may need to adjust parameters based on your data characteristics:

#### For dense, homogeneous tissues:

```{r}
STEAM.obj <- STEAMCorrection(STEAM.obj, 
                             k = 12, # More neighbors for stable regions 
                             min_consensus = 0.7, # Higher confidence threshold
                             min_secondary_consensus = 0.4, # Still allow some flexibility
                             max_iterations = 15, 
                             verbose = TRUE )
```

#### For heterogeneous or boundary-rich tissues

```{r}
STEAM.obj <- STEAMCorrection(
  STEAM.obj,
  k = 6,                     # Fewer neighbors to avoid cross-boundary effects
  min_consensus = 0.5,       # Lower threshold for primary corrections
  min_secondary_consensus = 0.25, # More aggressive secondary corrections
  max_voting_levels = 4,     # Allow 4th choice corrections
  verbose = TRUE
)

```

**Parameter Guidelines:**

-   **k (neighbors)**: 6-12 typically work well.
    Higher k = more stable but may blur boundaries

-   **min_consensus**: 0.5-0.8 range.
    Higher = conservative, lower = aggressive

-   **min_secondary_consensus**: Usually 0.3-0.5 of min_consensus

-   **max_iterations**: 10-20 iterations usually sufficient

-   **max_voting_levels**: 2-4 levels provide good coverage

## 2.4 Understanding the Output

```{r}
# Check correction summary across all folds
correction_results <- STEAM.obj$spatial_anchor_analysis$correction_results
for(fold_name in names(correction_results)) {
  fold_data <- correction_results[[fold_name]]
  cat(sprintf("Fold %d: %.1f%% → %.1f%% accuracy (%d corrections)\n",
              fold_data$fold_number,
              fold_data$initial_accuracy * 100,
              fold_data$final_accuracy * 100,
              fold_data$total_corrections))
}
```

## 2.5 Visualization and Analysis

### Iterative Correction

```{r}
# Show correction progress for a specific fold
IterativePlot(STEAM.obj, fold = 1)

# Show only key iterations
# IterativePlot(STEAM.obj, fold = 1, iterations = c(0, 2, 4, 6))

```

### Accuracy Improvements

```{r}
# Bar chart showing accuracy gains per fold
AccuracyPairedBarChart(STEAM.obj, show_corrections = FALSE)
```

### Neighborhood Analysis

```{r}
# Analyze when spatial correction works best
NeighborhoodHomogeneityAnalysis(STEAM.obj)
```

### Error Pattern Analysis

```{r}
# Which tissue types benefit most from correction?
ErrorAnalysisPlot(STEAM.obj)
```

## 3.6 Interpreting Results

### What Makes a Good Correction?

**High success indicators:**

-   High neighborhood homogeneity (\>60% neighbors same type)

-   Consistent voting across multiple neighbors

-   Cell located in tissue interior (not boundaries)

**Correction challenges:**

-   Boundary regions between tissue types

-   Isolated or rare cell types

-   Noisy spatial coordinates

-   Genuine biological heterogeneity

------------------------------------------------------------------------

# 4. Troubleshooting

**Common Issues:**

1.  **No corrections applied**:

    -   Check if you have misclassified cells: `getMisclassifiedCells(STEAM.obj)`

    -   Lower `min_consensus` threshold

    -   Increase `max_voting_levels`

2.  **Too many corrections**:

    -   Increase `min_consensus`

    -   Reduce `k` (fewer neighbors)

    -   Check for spatial coordinate errors

3.  **Poor correction quality**:

    -   Examine `NeighborhoodHomogeneityAnalysis()` results

    -   Consider tissue-specific parameter tuning

    -   Validate spatial coordinates are accurate

4.  **Slow performance**:

    -   Reduce `max_iterations`

    -   Use smaller `k` values

    -   Process folds sequentially if memory limited

## 4.1 Best Practices

1.  **Start with defaults** then tune based on your tissue characteristics

2.  **Examine results visually** using the plotting functions

3.  **Validate corrections** make biological sense for your system

4.  **Consider tissue boundaries** - corrections near boundaries may be less reliable

5.  **Document parameters** used for reproducibility

6.  **Cross-validate** correction performance on held-out data when possible

# 5. Session info

```{r session}
sessionInfo()
```
